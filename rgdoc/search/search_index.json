{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":""},{"location":"#what-is-it","title":"What is it?","text":"<p>raygpu is a fast and simple Graphics Library written in C99, inspired by and based on raylib. It targets Vulkan 1.1 or Vulkan 1.3 through WGVK and WebGPU through Dawn and emdawnwebgpu, a C wrapper for the WebGPU JS Api.</p> <p> </p> <p>Targeting Vulkan, Metal, DirectX 11/12, OpenGL (ES) and the WebGPU API in browsers makes raygpu a viable choice for portable desktop and browser application.</p>"},{"location":"#starter-code","title":"Starter Code","text":"<p>Designed to be as easy to use as possible, this is all the code required for a starter application. <pre><code>#include &lt;raygpu.h&gt;\nint main(){\n    InitWindow(500, 500, \"Window\");\n    while(!WindowShouldClose()){\n        BeginDrawing();\n        ClearBackground(BLACK);\n        DrawCircle(GetMouseX(), GetMouseY(), 50, 50, RED); //Draw a red circle at the cursor's position\n        EndDrawing();\n    }\n}\n</code></pre></p>"},{"location":"#building","title":"Building","text":""},{"location":"#minimal-compile-command","title":"Minimal compile command","text":"<p>Compiling a raygpu program for Web is as easy as running  <pre><code>emcc --use-port=emdawnwebgpu examples/core_shapes.c src/*.c -I include -I amalgamation/SPIRV-Reflect/ -sUSE_GLFW=3 -sALLOW_MEMORY_GROWTH=1 -sSINGLE_FILE=1 -o core_shapes.html\n</code></pre></p> <ul> <li><code>--use-port=emdawnwebgpu</code>: Use dawn's WebGPU bindings (might soon become -sUSE_WEBGPU=1)</li> <li><code>examples/core_shapes.c src/*.c</code>: One example's and the library's source code</li> <li><code>-I include -I amalgamation/SPIRV-Reflect/</code>: The required include directories</li> <li><code>-sUSE_GLFW=3</code>: Link emscriptens glfw3 library</li> <li><code>-sALLOW_MEMORY_GROWTH</code>: Don't get hit by out of memory errors, instead resize</li> <li><code>-sSINGLE_FILE</code>: Produce a single, \"executable\" html file</li> <li><code>-o core_shapes.html</code>: The output filename Make sure you have a recent version of emscripten installed.</li> </ul>"},{"location":"#cmake","title":"CMake","text":"<p>The primarily supported way to build is through CMake. Using the vulkan backend with GLSL Shaders and GLFW is also buildable with a plain Makefile.</p> <p>The CMake config supports a couple of options, namely</p> <ul> <li><code>SUPPORT_WGPU_BACKEND</code></li> <li><code>SUPPORT_VULKAN_BACKEND</code></li> <li><code>SUPPORT_GLFW</code></li> <li><code>SUPPORT_SDL3</code></li> <li><code>SUPPORT_GLSL_PARSER</code></li> <li><code>SUPPORT_WGSL_PARSER</code></li> </ul> <p>The options <code>SUPPORT_WGPU_BACKEND</code> and <code>SUPPORT_VULKAN_BACKEND</code> are mutually exclusive and one must be set.</p> <p>Those options can be appended to a cmake command line like this example:</p> <p><code>cmake .. -DSUPPORT_VULKAN_BACKEND=ON -DSUPPORT_GLSL_PARSER=ON -DSUPPORT_GLFW=ON</code></p> <p>Omitting both the <code>SUPPORT_WGPU_BACKEND</code> and <code>SUPPORT_WGSL_BACKEND</code> drastically reduces build-time, as dawn and tint are not built!</p> <p>For more info on cmake, scroll down to the CMake section</p>"},{"location":"#makefile","title":"Makefile","text":"<p><pre><code>git clone https://github.com/manuel5975p/raygpu/\ncd raygpu\nmake\n# or\nmake -j $(nproc)\n</code></pre> builds a static library <code>libraygpu.a</code> with the glfw and glslang libraries baked in. From there, an example can be built using <pre><code>g++ examples/core_window.c -o core_window -DSUPPORT_VULKAN_BACKEND=1 -I include/ -L . -lraygpu\n</code></pre></p>"},{"location":"#cmake_1","title":"CMake","text":"<p>If you want to add <code>raygpu</code> to your current project, add these snippets to your <code>CMakeLists.txt</code>: <pre><code># This is to support FetchContent in the first place.\n# Ignore if you already include it.\ncmake_minimum_required(VERSION 3.19)\ninclude(FetchContent)\n\nFetchContent_Declare(\n    raygpu_git\n    GIT_REPOSITORY https://github.com/manuel5975p/raygpu.git\n    GIT_SHALLOW True #optional, enable --depth 1 (shallow) clone\n)\nFetchContent_MakeAvailable(raygpu_git)\n\ntarget_link_libraries(&lt;your target&gt; PUBLIC raygpu)\n</code></pre></p>"},{"location":"#building-for-linux-or-macos","title":"Building for Linux or MacOS","text":"<p>Linux requires</p> <ul> <li>Ubuntu/Debian: <code>sudo apt install libvulkan-dev</code></li> <li>Arch / Manjaro: <code>sudo pacman -S vulkan-headers vulkan-swrast</code></li> <li>Fedora: <code>sudo dnf install vulkan</code></li> </ul> <pre><code>git clone https://github.com/manuel5975p/raygpu.git\ncd raygpu\nmkdir build &amp;&amp; cd build\ncmake .. -DCMAKE_BUILD_TYPE=Release # optionally: -GNinja\n\nmake -j8 # or ninja i.a.\n./examples/core_window\n</code></pre>"},{"location":"#building-for-windows","title":"Building for Windows","text":"<p><pre><code>git clone https://github.com/manuel5975p/raygpu.git\ncd raygpu\nmkdir build &amp;&amp; cd build\ncmake .. -DCMAKE_BUILD_TYPE=Release -G \"Visual Studio 17 2022\"\n</code></pre> See the complete list of generators for older Visual Studio versions.</p>"},{"location":"#building-for-web","title":"Building for Web","text":"<p>Building for web simply requires</p> <ul> <li>Using the WebGPU backend</li> <li>Having emscripten installed</li> </ul> <pre><code>git clone https://github.com/manuel5975p/raygpu.git\ncd raygpu\nmkdir build &amp;&amp; cd build\nemcmake cmake .. -DSUPPORT_WGPU_BACKEND=ON -DCMAKE_BUILD_TYPE=Release\n</code></pre>"},{"location":"api/","title":"API","text":""},{"location":"api/#initialization","title":"Initialization","text":"<p>The initialization functions set up the rendering backend, create a window, and manage the main application loop.</p> <ul> <li> <p><code>void InitWindow(int width, int height, const char* title)</code>     This is the primary function to initialize a window and the graphics context. It should be the first RayGPU function you call.</p> </li> <li> <p><code>void InitProgram(ProgramInfo program)</code>     A more structured way to initialize your application, taking a struct with window parameters and pointers to your <code>setup</code> and <code>render</code> functions.</p> </li> <li> <p><code>bool WindowShouldClose(void)</code>     This function returns <code>true</code> if the user has attempted to close the window (e.g., by clicking the 'X' button). It is typically used as the condition for the main game loop.</p> </li> <li> <p><code>void BeginDrawing(void)</code> and <code>void EndDrawing(void)</code>     These functions mark the beginning and end of a single frame's drawing commands. All drawing must happen between these two calls. <code>EndDrawing</code> handles buffer swapping and frame timing.</p> </li> <li> <p><code>void ClearBackground(Color color)</code>     Clears the entire screen to a specified color.</p> </li> <li> <p><code>void SetConfigFlags(int flag)</code>     Sets configuration flags for the window before it is created with <code>InitWindow</code>. Flags include <code>FLAG_FULLSCREEN_MODE</code>, <code>FLAG_WINDOW_RESIZABLE</code>, <code>FLAG_VSYNC_HINT</code>, and <code>FLAG_MSAA_4X_HINT</code>.</p> </li> </ul> <p>Example: Basic Window and Main Loop <pre><code>#include \"raygpu.h\"\n\nint main(void) {\n    InitWindow(800, 600, \"My RayGPU Window\");\n    SetTargetFPS(60);\n\n    while (!WindowShouldClose()) {\n        BeginDrawing();\n        ClearBackground(RAYWHITE);\n        DrawText(\"Hello, World!\", 190, 200, 20, BLACK);\n        EndDrawing();\n    }\n\n    // CloseWindow() is handled implicitly on loop exit in some backends,\n    // but cleanup functions for custom resources are the user's responsibility.\n    return 0;\n}\n</code></pre></p> <p>Example: Using <code>InitProgram</code> <pre><code>#include \"raygpu.h\"\n\nvoid Setup() {\n    // Initialization code goes here\n    SetTargetFPS(60);\n}\n\nvoid Render() {\n    // Drawing code for one frame goes here\n    BeginDrawing();\n    ClearBackground(DARKBLUE);\n    DrawFPS(10, 10);\n    EndDrawing();\n}\n\nint main(void) {\n    ProgramInfo info = {\n        .windowTitle = \"InitProgram Example\",\n        .windowWidth = 1280,\n        .windowHeight = 720,\n        .setupFunction = Setup,\n        .renderFunction = Render,\n    };\n    InitProgram(info);\n    return 0;\n}\n</code></pre></p>"},{"location":"api/#input","title":"Input","text":"<p>RayGPU provides a simple interface for polling keyboard, mouse, and touch input state once per frame.</p> <ul> <li><code>bool IsKeyDown(int key)</code>: Checks if a key is currently being held down.</li> <li><code>bool IsKeyPressed(int key)</code>: Checks if a key was just pressed in the current frame.</li> <li><code>bool IsMouseButtonDown(int button)</code>: Checks if a mouse button is currently being held down.</li> <li><code>bool IsMouseButtonPressed(int button)</code>: Checks if a mouse button was just pressed.</li> <li><code>Vector2 GetMousePosition(void)</code>: Returns the current X and Y coordinates of the mouse cursor.</li> <li><code>float GetMouseWheelMove(void)</code>: Returns the vertical scroll value of the mouse wheel.</li> <li><code>int GetCharPressed(void)</code>: Gets the next character pressed from a queue, useful for text input.</li> </ul> <p>Example: Keyboard and Mouse Input <pre><code>// Inside the main loop, after BeginDrawing()\nVector2 ballPosition = GetMousePosition();\n\nif (IsKeyDown(KEY_RIGHT)) ballPosition.x += 5.0f;\nif (IsKeyDown(KEY_LEFT)) ballPosition.x -= 5.0f;\nif (IsKeyDown(KEY_UP)) ballPosition.y -= 5.0f;\nif (IsKeyDown(KEY_DOWN)) ballPosition.y += 5.0f;\n\nColor ballColor = BLUE;\nif (IsMouseButtonDown(MOUSE_BUTTON_LEFT)) ballColor = RED;\n\nDrawCircleV(ballPosition, 30, ballColor);\n</code></pre></p>"},{"location":"api/#shapes","title":"Shapes","text":"<p>RayGPU includes a set of functions for drawing basic 2D and 3D geometric shapes in an immediate-mode style.</p> <ul> <li><code>void DrawPixel(int posX, int posY, Color color)</code>: Draws a single pixel.</li> <li><code>void DrawLine3D(Vector3 startPos, Vector3 endPos, Color color)</code>: Draws a line in 3D space.</li> <li><code>void DrawCircle(int centerX, int centerY, float radius, Color color)</code>: Draws a filled circle.</li> <li><code>void DrawRectangleRec(Rectangle rec, Color color)</code>: Draws a filled rectangle using a <code>Rectangle</code> struct.</li> <li><code>void DrawRectangleLinesEx(Rectangle rec, float lineThick, Color color)</code>: Draws the outline of a rectangle with a specified thickness.</li> <li><code>void DrawPoly(Vector2 center, int sides, float radius, float rotation, Color color)</code>: Draws a filled regular polygon.</li> </ul> <p>Example: Drawing Basic Shapes <pre><code>// Inside the main loop, after BeginDrawing()\nDrawRectangle(10, 10, 100, 50, BLUE);\nDrawCircle(200, 100, 40, RED);\nDrawLine(0, 200, GetScreenWidth(), 200, BLACK);\nDrawPoly((Vector2){GetScreenWidth() - 100, 100}, 6, 50, 0, VIOLET);\n</code></pre></p>"},{"location":"api/#instanced-drawing","title":"Instanced Drawing","text":"<p>Instancing allows you to draw many copies of the same mesh in a single draw call, each with its own transformation. This is achieved by passing an array of transformation matrices to the shader via a storage buffer.</p> <ul> <li><code>void DrawMeshInstanced(Mesh mesh, Material material, const Matrix *transforms, int instances)</code>: Draws a mesh multiple times using an array of transformation matrices.</li> </ul> <p>Example: Instanced Drawing in C <pre><code>// In your setup function:\n#define INSTANCE_COUNT 100\nMesh cube = GenMeshCube(1.0f, 1.0f, 1.0f);\nMatrix transforms[INSTANCE_COUNT];\n\nfor (int i = 0; i &lt; INSTANCE_COUNT; i++) {\n    float x = (float)(rand() % 20) - 10.0f;\n    float y = (float)(rand() % 20) - 10.0f;\n    float z = (float)(rand() % 20) - 10.0f;\n    transforms[i] = MatrixTranslate(x, y, z);\n}\nMaterial material = LoadMaterialDefault();\n\n// In your render loop (inside a 3D mode block):\nDrawMeshInstanced(cube, material, transforms, INSTANCE_COUNT);\n</code></pre></p> <p>Example: Corresponding Vertex Shader (WGSL) The default vertex shader is already set up for this. The <code>modelMatrix</code> storage buffer is indexed using the instance index. <pre><code>@group(0) @binding(3) var&lt;storage, read&gt; modelMatrix: array&lt;mat4x4f&gt;;\n\n@vertex\nfn vs_main(@builtin(instance_index) instanceIdx : u32, in: VertexInput) -&gt; VertexOutput {\n    var out: VertexOutput;\n    // Each instance gets its own model matrix from the storage buffer\n    out.position = Perspective_View * modelMatrix[instanceIdx] * vec4f(in.position.xyz, 1.0f);\n    // ... other assignments\n    return out;\n}\n</code></pre></p>"},{"location":"api/#textures-and-rendertextures","title":"Textures and Rendertextures","text":"<p>These functions handle loading, unloading, and drawing textures, as well as rendering to off-screen framebuffers (render textures).</p> <ul> <li><code>Texture LoadTexture(const char* filename)</code>: Loads a texture from an image file.</li> <li><code>void DrawTexturePro(...)</code>: An advanced texture drawing function with support for scaling, rotation, and drawing a portion of the source texture.</li> <li><code>RenderTexture LoadRenderTexture(uint32_t width, uint32_t height)</code>: Creates a render texture that can be used as a rendering target.</li> <li><code>void BeginTextureMode(RenderTexture rtex)</code> and <code>void EndTextureMode(void)</code>: Redirects all subsequent drawing commands to the specified render texture.</li> </ul> <p>Example: Loading and Drawing a Texture <pre><code>// In your setup function:\nTexture2D myTexture = LoadTexture(\"my_image.png\");\n\n// In your render loop:\nBeginDrawing();\n    ClearBackground(WHITE);\n    DrawTexture(myTexture, 100, 100, WHITE);\nEndDrawing();\n</code></pre></p> <p>Example: Rendering to a Texture <pre><code>// In your setup function:\nRenderTexture target = LoadRenderTexture(400, 300);\n\n// In your render loop:\nBeginTextureMode(target);\n    ClearBackground(SKYBLUE);\n    DrawRectangle(0, 0, 400, 300, RED);\n    DrawText(\"Rendered to texture\", 20, 20, 20, BLACK);\nEndTextureMode();\n\nBeginDrawing();\n    ClearBackground(LIGHTGRAY);\n    // Draw the render texture to the screen (flipped vertically)\n    DrawTextureRec(target.texture, (Rectangle){0, 0, target.texture.width, -target.texture.height}, (Vector2){0, 0}, WHITE);\nEndDrawing();\n</code></pre></p>"},{"location":"api/#separate-textures-and-samplers","title":"Separate Textures and Samplers","text":"<p>Unlike older graphics APIs, RayGPU (using modern backends like WebGPU) treats textures (the image data) and samplers (how the texture is read/filtered) as separate objects. There are no \"combined image samplers\". You must declare and bind them separately in your custom shaders.</p> <ul> <li><code>DescribedSampler LoadSampler(TextureWrap amode, TextureFilter fmode)</code>: Creates a sampler object.<ul> <li><code>TextureWrap</code>: Defines behavior for texture coordinates outside the <code>[0, 1]</code> range (e.g., <code>TEXTURE_WRAP_REPEAT</code>, <code>TEXTURE_WRAP_CLAMP</code>).</li> <li><code>TextureFilter</code>: Defines filtering for magnification and minification (e.g., <code>TEXTURE_FILTER_POINT</code>, <code>TEXTURE_FILTER_BILINEAR</code>).</li> </ul> </li> </ul> <p>Example: GLSL Shader with Separate Texture and Sampler <pre><code>#version 450\n\nlayout(location = 0) in vec2 frag_uv;\nlayout(location = 1) in vec4 frag_color;\n\nlayout(location = 0) out vec4 outColor;\n\n// Binding 1 for the texture data\nlayout(binding = 1) uniform texture2D texture0;\n// Binding 2 for the sampler configuration\nlayout(binding = 2) uniform sampler texSampler;\n\nvoid main() {\n    // Combine them at sample time\n    vec4 texColor = texture(sampler2D(texture0, texSampler), frag_uv);\n    outColor = texColor * frag_color;\n}\n</code></pre></p> <p>Example: C Code to Bind Texture and Sampler <pre><code>// Load a custom shader that uses separate samplers\nShader myShader = LoadShader(NULL, \"my_shader.frag\");\nTexture myTexture = LoadTexture(\"my_texture.png\");\n\n// Create a sampler with repeat wrapping and bilinear filtering\nDescribedSampler mySampler = LoadSampler(TEXTURE_WRAP_REPEAT, TEXTURE_FILTER_BILINEAR);\n\n// In the render loop...\nBeginShaderMode(myShader);\n\n    // Get uniform locations\n    int texLoc = GetUniformLocation(myShader, \"texture0\");\n    int samplerLoc = GetUniformLocation(myShader, \"texSampler\");\n\n    // Bind the texture to its location\n    SetShaderTexture(myShader, texLoc, myTexture);\n\n    // Bind the sampler to its location\n    SetShaderSampler(myShader, samplerLoc, mySampler);\n\n    // Draw your geometry\n    DrawRectangle(0, 0, GetScreenWidth(), GetScreenHeight(), WHITE);\n\nEndShaderMode();\n</code></pre></p>"},{"location":"api/#camera2d-3d-the-matrix-stack","title":"Camera2D / 3D / The Matrix Stack","text":"<p>RayGPU manages transformations using a matrix stack and provides camera abstractions for easy 2D and 3D scene setup.</p> <ul> <li><code>void BeginMode2D(Camera2D camera)</code> and <code>void EndMode2D(void)</code>: Sets up a 2D orthographic projection. All drawing between these calls is transformed by the camera's view.</li> <li><code>void BeginMode3D(Camera3D camera)</code> and <code>void EndMode3D(void)</code>: Sets up a 3D perspective projection.</li> <li><code>void rlPushMatrix(void)</code>: Pushes (saves) the current transformation matrix.</li> <li><code>void rlPopMatrix(void)</code>: Pops (restores) the last saved matrix.</li> <li><code>void rlLoadIdentity(void)</code>: Resets the current matrix to the identity matrix.</li> </ul> <p>Example: A Simple 2D Camera <pre><code>// In your setup function:\nCamera2D camera = { 0 };\ncamera.target = (Vector2){ 400.0f, 300.0f };\ncamera.offset = (Vector2){ GetScreenWidth()/2.0f, GetScreenHeight()/2.0f };\ncamera.rotation = 0.0f;\ncamera.zoom = 1.0f;\n\n// In your render loop:\ncamera.zoom += GetMouseWheelMove() * 0.05f; // Zoom with mouse wheel\nif (camera.zoom &gt; 3.0f) camera.zoom = 3.0f;\nelse if (camera.zoom &lt; 0.1f) camera.zoom = 0.1f;\n\nBeginDrawing();\n    ClearBackground(WHITE);\n    BeginMode2D(camera);\n        // Draw world-space objects here\n        DrawRectangle(-100, -100, 200, 200, RED);\n    EndMode2D();\n    // Draw screen-space UI here\n    DrawText(\"This is a 2D camera!\", 10, 10, 20, DARKGRAY);\nEndDrawing();\n</code></pre></p>"},{"location":"api/#compute-shaders","title":"Compute Shaders","text":"<p>RayGPU provides an interface for leveraging GPU compute capabilities for general-purpose parallel processing.</p> <ul> <li><code>DescribedComputePipeline* LoadComputePipeline(const char* shaderCode)</code>: Loads and compiles a compute shader from a WGSL source string.</li> <li><code>DescribedBuffer* GenStorageBuffer(const void* data, size_t size)</code>: Creates a GPU buffer for read/write access in shaders.</li> <li><code>void BeginComputepass(void)</code> and <code>void EndComputepass(void)</code>: Delimits a block of compute-related commands.</li> <li><code>void BindComputePipeline(DescribedComputePipeline* cpl)</code>: Sets the active compute pipeline.</li> <li><code>void SetBindgroupStorageBuffer(...)</code>: Binds a storage buffer to a specified binding point.</li> <li><code>void DispatchCompute(uint32_t x, uint32_t y, uint32_t z)</code>: Executes the compute shader with a specified number of workgroups.</li> </ul> <p>Example: WGSL Compute Shader to Modify a Buffer <pre><code>// shader.wgsl\n@group(0) @binding(0) var&lt;storage, read_write&gt; data: array&lt;f32&gt;;\n\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;) {\n    let index = global_id.x;\n    data[index] = f32(index) * 2.0;\n}\n</code></pre></p> <p>Example: C Code to Run the Compute Shader <pre><code>// In your setup function:\nconst int ELEMENT_COUNT = 256;\nfloat initialData[ELEMENT_COUNT] = { 0 };\nDescribedBuffer* myBuffer = GenStorageBuffer(initialData, sizeof(initialData));\n\n// Load the shader from file or string\nchar* computeShaderCode = LoadFileText(\"shader.wgsl\");\nDescribedComputePipeline* myComputePipeline = LoadComputePipeline(computeShaderCode);\nUnloadFileText(computeShaderCode);\n\n// Bind the buffer to binding point 0 of the pipeline's bindgroup\nSetBindgroupStorageBuffer(&amp;myComputePipeline-&gt;bindGroup, 0, myBuffer);\n\n// In your update/render function (can be called once):\nBeginComputepass();\n    BindComputePipeline(myComputePipeline);\n    // Dispatch enough workgroups to cover all elements.\n    // Workgroup size is 64, so we need 256/64 = 4 workgroups.\n    DispatchCompute(4, 1, 1);\nEndComputepass();\n\n// To read the data back (this is a slow operation):\n// You would typically use another compute or render shader to consume the buffer on the GPU.\n// For verification, you can map it back to the CPU. This requires more complex buffer mapping logic not shown here.\n</code></pre></p>"},{"location":"usage/","title":"Usage","text":"<p>A very basic usage example: <pre><code>#include &lt;raygpu.h&gt;\nint main(){\n    InitWindow(800, 600, \"Title\");\n    while(!WindowShouldClose()){\n        BeginDrawing();\n        ClearBackground(GREEN);\n        DrawText(\"Hello there!\", 200, 200, 30, BLACK);\n        EndDrawing();\n    }\n}\n</code></pre></p>"},{"location":"usage/#emscripten","title":"Emscripten","text":"<p>TLDR</p> <ul> <li>Use <code>emscripten_set_main_loop</code> to use raygpu with <code>-sASYNCIFY=2 -DASSUME_EM_ASYNCIFY</code></li> <li>Use <code>InitProgram</code> to use raygpu without <code>-sASYNCIFY</code></li> </ul>"},{"location":"usage/#the-render-loop","title":"The Render Loop","text":"<p>C/C++ programs usually implement a render loop as a regular while loop: <pre><code>int main(){\n    // Init\n    while(!WindowShouldClose()){\n        // Render and present\n    }\n}\n</code></pre> When the program flow returns from <code>main</code>, the application is finished and exits. <code>int main</code> is therefore a big, blocking function that \"blocks\" until the end of the programs life.</p>"},{"location":"usage/#behaviour-under-emscripten","title":"Behaviour under emscripten","text":"<p>In WebAssembly via Emscripten, main is only the entry point. Once it returns, control goes back to the browser. To keep running, you must explicitly schedule a loop with emscripten_set_main_loop. A plain blocking loop inside main will freeze the page - no input, no redraw, and the tab becomes unresponsive until closed. The same applies in JavaScript: an endless loop blocks the event loop and locks the page.</p>"},{"location":"usage/#asyncify","title":"Asyncify","text":"<p>Emscripten's developers have come up with a fix to this: the <code>-sASYNCIFY</code> flag: It generates wasm that can be interrupted by the browser to get some time to do input processing, to be resumed in the exact same state right after. This comes with an overhead both in code size and performance.</p> <p>With WebGPU the Renderloop is not the only place where returning the program flow to the browser is required. The functions <code>wgpuInstanceRequestAdapter</code> and <code>wgpuAdapterRequestDevice</code> both return a <code>WGPUFuture</code>, which hands you the created Adapter / Device in a callback. Those callbacks only fire when </p> <ul> <li>Control is back at the browser (no wasm running from our side)</li> <li>You explicitly calling <code>wgpuInstanceWaitAny</code> on the Future (requires <code>-sASYNCIFY=2</code>!!) </li> </ul> <p>So in short: Without <code>ASYNCIFY</code>, neither <code>InitWindow</code> nor the renderloop can live inside <code>int main</code>.</p>"},{"location":"usage/#initprogram","title":"InitProgram","text":"<p>RayGPU provides <code>InitProgram(ProgramInfo info)</code> to handle initialization, run a setup function once, and manage the render loop:</p> <p><pre><code>#include &lt;raygpu.h&gt;\nTexture tex = {0};\n\n// This function only runs once\nvoid setup(){\n    tex = LoadTextureFromImage(GenImageChecker(WHITE, BLACK, 100, 100, 10));\n}\n\n// This function gets called repeatedly\nvoid render(){\n    BeginDrawing();\n    ClearBackground((Color) {20,50,50,255});\n\n    DrawRectangle(100,100,100,100,WHITE);\n    DrawTexturePro(tex, CLITERAL(Rectangle) {0,0,100,100}, CLITERAL(Rectangle){200,100,100,100}, (Vector2){0,0}, 0.0f, WHITE);\n    DrawCircle(GetMouseX(), GetMouseY(), 40, WHITE);\n    DrawCircleV(GetMousePosition(), 20, CLITERAL(Color){255,0,0,255});\n    DrawCircle(600, 300, 200, CLITERAL(Color){255,0,0,100});\n\n    DrawFPS(5, 5);\n    EndDrawing();\n}\n\nint main(void){\n    ProgramInfo program = {\n        .windowTitle = \"Shapes Example\",\n        .windowWidth = 800,\n        .windowHeight = 600,\n        .setupFunction = setup,\n        .renderFunction = render\n    };\n    InitProgram(program); //This function blocks on desktop\n}\n</code></pre> When compiled for a desktop platform, the call to InitProgram is equivalent to this: <pre><code>InitWindow(800, 600, \"Shapes Example\");\nsetup();\nwhile(!WindowShouldClose()){\n    render();\n}\n</code></pre> On wasm, the internal logic differs to avoid blocking, but the result is equivalent.</p>"}]}